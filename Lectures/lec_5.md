Google Colab(Jupyter).
Знакомство с аналитикой.

● Чтение и предварительный просмотр данных
● Выбор данных
● Простая статистика
● Изображаем статистические отношения
● Линейные графики
● Гистограмма

Знакомство с аналитикой
Знакомство с аналитикой. Мы будем пользоваться таким
инструментом как Google Сolab
На лекции мы познакомимся с инструментом для работы с
табличными данными(pandas) и способами визуализации данных с
помощью библиотек matplotlib и seaborn. Прежде, чем приступать
непосредственно к машинному обучению, важно произвести
EDA(Exploratory Data Analysis) - Разведочный анализ данных.
Он состоит в анализе основных свойств данных, нахождения в них
общих закономерностей, распределений и аномалий, построение
начальных моделей, зачастую с использованием инструментов
визуализации.

Знакомство с аналитикой
Понятие введено математиком Джоном Тьюки, который
сформулировал цели такого анализа следующим образом:
1. Максимальное «проникновение» в данные
2. Выявление основных структур
3. Выбор наиболее важных переменных
4. Обнаружение отклонений и аномалий
5. Проверка основных гипотез
Базовые функции для работы с данными
Библиотека pandas может читать многие форматы, включая: .csv,
.xslx, .xls, .txt, sql и многие другие. Полный список по ссылке
Чтобы подключить библиотеку к Вашей программе необходимо
написать следующее:
import pandas as pd
Напоминание: as(alias) - псевдоним. Мы можем сократить название
все библиотеки до 2-х букв.
Прочтем файл .csv(он находится в Google Colab в папке sample_data) с
помощью библиотеки pandas
df = pd.read_csv('sample_data/california_housing_train.csv')

Базовые функции для работы с данными
Для того чтобы прочитать первые n строк таблицы, необходимо
воспользоваться следующей функцией:
DataFrame.head(n=5)
Где DataFrame - это таблица с данными, которая предварительно была
открыта. Мы ее открыли и записали в переменную df. Необязательно
указывать n=5, вместо 5 мы можем указать любое число(число не должно
превосходить количество строк в таблице). Если Вы ничего не укажете в
круглых скобках, то ошибка не вылезет, по умолчанию будут выведены
первые 5 строк таблицы.
Пример:
df.head()

Базовые функции для работы с данными
Пример:
df.head()
Результат:
Как мы знаем, в нашем мире почти все симметрично, есть отрицательные числа, а
есть положительные и тд. Значит, если есть функция, которая показывает первые
5 строк таблицы, то и есть функция, которая показывает последние 5 строк
таблицы. Давайте с ней познакомимся.
Базовые функции для работы с данными
Пример:
df.tail()
Результат:
Данная функция работает аналогично с head(). Необязательно выводить
последние 5 строчек, можно указать сколько угодно.
Базовые функции для работы с данными
Иногда заранее неизвестно сколько строк и столбцов находится внутри
таблицы, чтобы это сделать необходимо воспользоваться специальной
функцией.
Пример:
df.shape
Результат:
(17000, 9)
Функция shape возвращает размеры таблицы: кортеж из 2 значений, 1 -
количество строк, 2 - количество столбцов.

Базовые функции для работы с данными
Согласитесь, что все не раз делали заказ на каком-нибудь маркетплейсе. И когда мы
заполняли поле “Email”, то могли его пропустить, потому что указанно, что оно
необязательное и не хотели видеть лишнего спама. Вы когда-нибудь задумывались,
как в этом случае эти данные будут выглядеть внутри базы данных(таблице)?
Пропуск? Пустая ячейка? Нет. Когда нужно указать, что в данной ячейки таблицы
ничего нет указывается значение null.
Чтобы обнаружить пустые значения в таблице данных необходимо воспользоваться
функцией .isnull().
Пример:
df.isnull()

Базовые функции для работы с данными
Функция привела нашу таблицу к следующему виду True-False, где True -
это пустая ячейка, False - это заполненная ячейка. Но это неудобно, то есть
нам надо просматривать 17 000 * 9 = 153 000 ячеек. Вау… Это займет
слишком много времени. Однако, мы можем воспользоваться еще одной
функцией .sum(). Данная функция выведет количество null-значений в
каждой ячейке по столбцам.
Пример:
df.isnull().sum()

Базовые функции для работы с данными
Можно сделать следующий вывод: пустые значения в нашей таблицы
отсутствуют.
Еще при работе с C#, мы поняли, что у каждой переменной есть свой тип
данных. Также и здесь, у каждого столбца есть свой тип данных, чтобы это
узнать, нужно применить функцию .dtypes.
Пример:
df.dtypes

Базовые функции для работы с данными
Чтобы узнать название всех столбцов в таблице, воспользуйтесь функцией
.columns.
Пример:
df.columns

Выборка данных
Если Вы хотите вывести 1 столбец на экран, то можно указать следующее
выражение, которое позволит это сделать.
Пример:
df['latitude']

Выборка данных
Что мы будем делать, если нам потребуется вывести на экран сразу
несколько столбцов? Не очень удобно будет это прописывать вот таким
образом:
print(df['latitude'])
print(df['population'])
Конечно есть решение данного вопроса
Пример:
df[['latitude', 'population']]

Задача
Задание: Необходимо вывести столбец total_rooms, у которого медианный
возраст здания(housing_median_age) меньше 20.
Для того чтобы решить это задание, давайте познакомимся с синтаксисом
выборки данных. На самом деле, это ничем не отличается от операторов
ветвления.
Решение:
df[df['housing_median_age'] < 20]

Задача
Если Вам нужно поставить другое условие, то аналогично.
Мы помним с C#, что иногда приходится проверять несколько условий сразу. Чтобы
проверить несколько условий внутри Google Colab, указывается так:
df[(df['housing_median_age'] > 20) & (df['total_rooms'] > 2000)]
& - выполнение одновременно всех условий.
| - выполнение хотя бы одного из условия.

Задача
Первую часть задания мы успешно выполняли! Только загвоздка… Нам не нужна вся таблица, а лишь один
столбец, как это сделать?
Решение:
df[df['housing_median_age'] < 20, 'total_rooms']
# или (если необходимо вывести 2 и более столбцов
df[df['housing_median_age'] < 20, ['total_bedrooms', 'total_rooms']]

Простая статистика
Pandas позволяет получить основные простые данные для описательной статистики. Такие как минимальное
значение в столбце, максимальное значение, сумма всех значений, среднее значение
Максимальное значение:
print(df['population'].max())
Минимальное значение:
print(df['population'].min())
Среднее значение:
print(df['population'].mean())
Сумма:
print(df['population'].sum())
Медианное значение для нескольких столбцов:
df[['population', 'total_rooms']].median()

Простая статистика
Перцентиль - это показатель, используемый в статистике, показывающий значение, ниже которого падает
определенный процент наблюдений в группе наблюдений
Получить общую картину можно простой командой describe
df.describe()
count - Общее кол-во не пустых строк, mean - среднее значение в столбце
std - стандартное отклонение от среднего значения, min - минимальное значение,
max - максимальное значение
Числа 25%, 50%, 75% - перцентили
Изображаем статистические отношения
Scatterplot (Точечный график)
Математическая диаграмма, изображающая значения двух переменных в виде точек на декартовой плоскости.
Библиотека seaborn без труда принимает pandas DataFrame(таблицу). Чтобы изобразить отношения между
двумя столбцами достаточно указать, какой столбец отобразить по оси x, а какой по оси y.
Для того чтобы начать работу с библиотекой seaborn, ее необходимо импортировать к себе в программу:
import seaborn as sns
Вернемся к нашей таблице. Можно заметить, что дома расположены в определенной "полосе" долготы и
широты.

Изображаем статистические отношения
Изображение точек долготы по отношению к широте:
sns.scatterplot(data=df, x="longitude", y="latitude")

Изображаем статистические отношения
Помимо двумерных отношений, мы можем добавить "дополнительное измерение" с помощью цвета. В данном
случае опять же достаточно очевидное отношение, чем выше кол-во семей, тем выше кол-во людей и
соответственно комнат.
Пример:
sns.scatterplot(data=df, x="households", y="population", hue="total_rooms")

Линейные графики
Хорошо подойдут, если есть временная или какая-либо иная последовательность и значения, которые могут
меняться в зависимости от нее. Для генерации линейных графиков в seaborn используется relplot функцию. Она
также принимает DataFrame, x, y - столбцы.
Для визуализации выбирается тип line:
sns.relplot(x="latitude", y="median_house_value", kind="line", data=df)

Линейные графики
Можно видеть, что в определенных местах долготы цена за дома резко подскакивает.
Попробуем визуализировать longitude по отношения к median_house_value и поймем в чем же дело, почему
цена так резко подскакивает.
Пример:
sns.relplot(x = 'longitude', y = 'median_house_value', kind = 'line', data = df)

Линейные графики
Можно видеть, что в определенных местах широты цена за дома также очень высока.
Используя точечный график можно визуализировать эти отношения с большей четкостью. Скорее всего резкий
рост цен связан с близостью к ценному объекту, повышающему качество жизни, скорее всего побережью
океана или реки.
Пример:
sns.scatterplot(data=df, x="latitude", y="longitude", hue="median_house_value")
Гистограмма
Способ представления табличных данных в графическом виде — в виде столбчатой диаграммы. По оси x обычно
указывают значение, а по оси y - встречаемость(кол-во таких значений в выборке).
Пример:
sns.histplot(data=df, x="median_income")

Гистограмма
Можно видеть что у большинства семей доход находится между значениями 2 и 6. И только очень небольшое
количество людей обладают доходом > 10.
Изобразим гистограмму по housing_median_age.
Пример:
sns.histplot(data = df, x = 'housing_median_age')
Гистограмма
Распределение по возрасту более равномерное. Большую часть жителей составляют люди в возрасте от 20 до
40 лет. Но и молодежи не мало. Также очень много пожилых людей > 50 лет медианный возраст.
Давайте посмотрим медианный доход у пожилых жителей.
Пример:
sns.histplot(data=df[df['housing_median_age']>50], x="median_income") Большого отличия от популяции
в целом не наблюдается.
Скорее всего это местные
жители.
Гистограмма
Давайте разобьем возрастные группы на 3 категории те кто моложе 20 лет, от 20 до 50 и от 50, чтобы посмотреть
влияет ли это на доход.
Пример:
df.loc[df['housing_median_age'] <= 20, 'age_group'] = 'Молодые'
df.loc[(df['housing_median_age'] > 20) & (df['housing_median_age'] <= 50), 'age_group'] = 'Ср. возраст'
df.loc[df['housing_median_age'] > 50, 'age_group'] = 'Пожилые'
Что в этом случае происходит внутри таблицы? Добавился новый столбец age_group, в котором будет указана
соответствующая категория.
Гистограмма
Применим group_by, чтобы получить среднее значение.
df.groupby('age_group')['median_income'].mean().plot(kind='bar')
Молодые оказываются самой богатой группой населения. Но отличие в доходе не значительное.
Гистограмма
Seaborn так же позволяет нам смотреть распределение по многим параметрам. Давайте поделим группы по доходам
на 2. Те у кого медианный доход выше 6 и те у кого меньше. Изобразим дополнительное измерение с помощью
оттенка в виде возрастных групп и групп по доходам.
df.loc[df['median_income'] > 6, 'income_group'] = 'rich'
df.loc[df['median_income'] < 6, 'income_group'] = 'everyone_else'
 sns.displot(df, x="median_house_value", hue="income_group")
Гистограмма

Итоги
Анализ данных должен предоставлять информацию и инсайт, которые не видны
невооруженным взглядом. В этом и есть красота аналитики. В данном случае можно сделать
следующий выводы. Стоимость домов напрямую зависит от их расположения, в
определенной полосе(скорее всего побережье) цена на дома высокая. Чем выше доход, тем
больше шанс, что человек проживает в богатом районе. Распределение по возрастам
примерно одинаковое во всех группах доходов. Ну и очевидно чем больше людей, тем
больше семей, и соответственно комнат и спален.
Спасибо за внимание!

DataFrame.head(n=5)
Параметры:
n: int, значение по умолчанию 5
# Посмотреть первые 5 строк 
df.head()
DataFrame.tail(n=5)
Параметры:
n: int, значение по умолчнию 5
# Посмотреть последние 5 строк
df.tail()
# Возвращает размеры таблицы: кортеж из 2 значений, 1 ко
л-во строк, 2 - кол-во столбцов
df.shape
# Посмотреть есть ли у нас пусты
е значения
# В данном случае пустых значен
ий нет
df.isnull().sum()
# Посмотреть все столбцы
# Возвращает список со строкам
и строк - названиями столбцов в 
таблице
df.columns
DataFrame.isnull() - обнаруживает пустые значения
DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs) -
возвращает сумму значений по выбраной оси
Параметры:
axis: int {index (0), columns (1)} - ось(0 - вертикальная, 1 - горизонтальная)
По умолчанию 0
# Проверить тип данных в столбц
ах
# В данных случаях везде float, ч
исло 64 указывает на разрядност
ь(Используется 64 байта для хра
нения значения в памяти,
# чем меньше разрядность, тем м
еньший диапазон могут принима
ть числа и тем меньше тратится п
амяти на хранение.
df.dtypes
Медиана набора чисел — число, которое находится в середине этого набора, если его
упорядочить по возрастанию, то есть такое число, что половина из элементов набора не
меньше него, а другая половина не больше.
В данном случае у нас следующие строки:
1. longitude – долгота
2. latitude – широта
3. housing_median_age - медианный возраст зданий
4. total_rooms - общее кол-во зданий
5. total_bedrooms - Общее кол-во спален
6. population - кол-во жителей
7. households - кол-во семей
8. median_house_value - медианная стоимость дома
Выбор данных
# Выбор 1 столбца - [широты]
df['latitude']
# Выбор нескольких столбцов [широта, колво жителей]
df[['latitude', 'population']]
# Выбор определенного кол-ва рядов
# Синтаксис df[df[col] !=|==|>|<| значение]
df[df['housing_median_age'] < 20]
# Для отбора можно использовать несколько у
словий одновременно
# Знак & означает 'and', а знак | 'or'
df[(df['housing_median_age'] > 20) & (df['total_ro
oms'] > 2000)]
df[(df['housing_median_age'] > 20) | (df['total_ro
oms'] > 2000)]
# Выбор определенного колва рядов и столбцов
# используется метод loc в [], первый аргумент
 индекс или селектор, а второй список со столб
цами
df.loc[df['population'] < 100, ['total_bedrooms', 't
otal_rooms']]
Простая статистика
Pandas позволяет получить основные простые
данные для описательной статистики
Такие как минимальное значение в столбце,
максимальное значение, сумма всех значений,
среднее значение
# Максимальное значение
print(df['population'].max())
# Минимальное значение
print(df['population'].min())
# Среднее значение
print(df['population'].mean())
# Сумма
print(df['population'].sum())
Эту же статистику можно рассчитывать сразу для
нескольких столбцов
# Медианное значение
df[['population', 'total_rooms']].median()
 population 1155.0
total_rooms 2106.0
dtype: float64
Получить общую картину можно простой командой describe
df.describe()
count - Общее кол-во не пустых строк
mean - среднее значение в столбце
std - стандартное отклонение от среднего значения
min - минимальное значение
max - максимальное значение
Числа 25%, 50%, 75% - перцентили
> Перцентиль - это показатель, используемый в статистике, показывающий значение, ниже которого падает
определенный процент наблюдений в группе наблюдений

На лекции мы познакомимся с инструментами и
способами визуализации данных с помощью
библиотек matplotlib и seaborn.
 Прежде, чем приступать непосредственно к
машинному обучению, важно произвести EDA
(Exploratory Data Analysis) - Разведочный анализ
данных.
 Он состоит в анализе основных свойств данных,
нахождения в них общих закономерностей,
распределений и аномалий, построение начальных
моделей, зачастую с использованием инструментов
визуализации.
Понятие введено математиком Джоном Тьюки,
который сформулировал цели такого анализа
следующим образом:
1. Максимальное «проникновение» в данные
2. Выявление основных структур
3. Выбор наиболее важных переменных4.
Обнаружение отклонений и аномалий5. Проверка
основных гипотез
# Библиотека для работы с табли
чными данными
import pandas as pd
# Библиотека для вычислений ли
нейной алгебры
import numpy as np
# Библиотеки для визуализации
import seaborn as sns
import matplotlib.pyplot as plt
# Первые пять строк
df.head()
# Начнем с чтения csv данных
df = pd.read_csv('sample_data/cali
fornia_housing_train.csv')
Изображаем статистические
отношения
Математическая диаграмма, изображающая значения двух переменных в виде точек на декартовой
плоскости.
Библиотека seaborn без труда принимает pandas DataFrame(таблицу). Чтобы изобразить отношения между
двумя столбцами достаточно указать, какой стобец отоброзить по оси x, а какой по оси y.
# Изображения точек долготы по отношению к широте.
# Можно заметить, что дома расположены в определенной "полосе" долготы и широты
sns.scatterplot(data=df, x="longitude", y="latitude")
 # Самостоятельная работа №1
 # Изобразите отношение households к population
 sns.scatterplot(data = df, x = 'households', y = 'population')
Scatterplot (Точный график)
Помимо двумерных отношений, мы можем добавить "дополнительное измерение" с помощью цвета. В
данном случае опять же достаточно очевидное отношение, чем выше кол-во семей, тем выше кол-во
людей и соответственно комнат
sns.scatterplot(data=df, x="households", y="population",  hue="total_rooms")
Помимо обозначения дополнительного измерения цветом мы можем использовать size
# Самостоятельная работа №2
# Добавьте total_rooms используя дополнительное и
змерение size
sns.scatterplot(data=df, x="households", y="population
",  hue="total_rooms", size = 4)
Мы можем визуализировать сразу несколько
отношений используя класс PairGrid внутри seaborn
PairGrid принимает как аргумент pandas DataFrame и
визуализирует все возможные отношения между
ними, в соответствии с выбранным типом графика.
cols = ['population', 'median_income', 'housing_median_ag
e', 'median_house_value']
g = sns.PairGrid(df[cols])
g.map(sns.scatterplot)
Как вы думаете, чем вызвана линейная зависимость
по диагонали?
Вопрос
Линейные графики
Хорошо подойдут, если есть временная или какаялибо иная последовательность и значения, которые
могут меняться в зависимости от неё.
Для генерации линейных графиков в seaborn
используется relplot функция. Она также принимает
DataFrame, x, y - столбцы.
# Для визуализации выбирается тип line
sns.relplot(x="latitude", y="median_house_value", kind
="line", data=df)
Можно видеть, что в определенных местах долготы
цена за дома резко подскакивает.
# Самостоятельная работа №3
# Визуализировать longitude по отношения к median
_house_value
# Используя линейный график
sns.relplot(x = 'longitude', y = 'median_house_value', ki
nd = 'line', data = df)
Можно видеть, что в определеных местах широты
цена за дома также очень высока
Используя точечный график можно визуализировать эти отношения с большей
четкостью. Скорее всего резкий рост цен связан с близостью к ценному объекту,
повышающему качество жизни, скорее всего побережью океана или реки.
sns.scatterplot(data=df, x="latitude", y="longitude",  hue="median_house_value")
Гистограмма
Способ представления табличных данных в
графическом виде — в виде столбчатой диаграммы.
По оси x обычно указывают значение, а по оси y -
встречаемость(кол-во таких значений в выборке)
sns.histplot(data=df, x="median_income")
Можно видеть что у большинства семей доход
находится между значениями 2 и 6.И только очень
небольшое ко-во людей обладают доходом > 10
# Самостоятельная работа №5
# Изобраить гистограмму по housing_median_age
sns.histplot(data = df, x = 'housing_median_age')
Распределение по возрасту более равномерное.
Большую часть жителей составляют люди в возрасте
от 20 до 40 лет. Но и молодежи не мало. Также очень
много пожилых людей > 50 лет медианный возраст.
Давайте посмотрим медианный доход у пожилых
жителей
sns.histplot(data=df[df['housing_median_age']>50], x="
median_income")
Большого отличия от популяции в целом не
наблюдается. Скорее всего это местные жители.
Давайте посмотрим на популяцию
sns.histplot(data=df, x="population", binwidth=1000)
Разобьем возрастные группы на 3 категории те кто моложе 20 лет, от 20 до 50 и от 50, чтобы посмотреть
влияет ли это на доход.
df.loc[df['housing_median_age'] <= 20, 'age_group'] = 'Молодые'
df.loc[(df['housing_median_age'] > 20) & (df['housing_median_age'] <= 50), 'age_group'] = 'Ср. возраст'
df.loc[df['housing_median_age'] > 50, 'age_group'] = 'Пожилые‘
Применим group_by, чтобы получить среднее значение
df.groupby('age_group')['median_income'].mean().plot(kind='bar')
Молодые оказываются самой богатой группой населения. Но отличие в доходе не значительное.
Seaborn так же позволяет нам смотреть распределение по многим параметрам.
Давайте поделим группы по доходам на 2. Те у кого медианный доход выше 6 и те у кого меньше. Изобразим
дополнительное измерение с помощью оттенка в виде возрастных групп и групп по доходам.
df.loc[df['median_income'] > 6, 'income_group'] = 'rich'
df.loc[df['median_income'] < 6, 'income_group'] = 'everyone_else‘
sns.displot(df, x="median_house_value", hue="income_group")
Heatmaps (Корелляция)
Посмотрим как данные коррелируют между собой
corr = df.corr()
mask = np.triu(np.ones_like(corr, dtype=bool))
# Создаем полотно для отображения большого
 графика
f, ax = plt.subplots(figsize=(11, 9))
# Создаем цветовую политру
cmap = sns.diverging_palette(230, 20, as_cmap=
True)
# Визуализируем данные кореляции 
sns.heatmap(corr, mask=mask, cmap=cmap, vma
x=.3, center=0,
            square=True, linewidths=.5, cbar_kws={"sh
rink": .5})
Выводы
Анализ данных должен предоставлять информацию и инсайт, которые не видные невооруженным взглядом.
В этом и есть красота аналитики. В данном случае можно сделать следующий выводы. Стоимость домов
напрямую зависит от их расположения, в определенной полосе(скорее всего побережье) цена на дома
высокая. Чем выше доход, тем больше шанс, что человек проживает в богатом районе. Возраст никак не
коррелирует с доходом. Распределение по возрастам примерно одинаковое во всех группах доходов. Ну и из
очевидно чем больше людей, тем больше семей, и соответственно комнат и спален.
Объяснение
penguins = sns.load_dataset("penguins")
# Первые 5 строк датасета про пингвинов
penguins.head()
sns.scatterplot(data = penguins, x = 'bill_length_
mm', y = 'bill_depth_mm', hue = 'sex', size = 5)
sns.scatterplot(data = penguins, x = 'body_mass
_g', y = 'flipper_length_mm', hue = 'sex', size = 6)
sns.scatterplot(data = penguins, x = 'bill_depth_
mm', y = 'bill_length_mm', hue = 'body_mass_g', 
size = 4)
lst = ['bill_length_mm', 'bill_depth_mm', 'flipper_length_m
m', 'body_mass_g', 'sex']
g = sns.PairGrid(penguins[lst])
g.map(sns.scatterplot)
sns.histplot(data = penguins, x = 'bill_depth_mm')
sns.histplot(data = penguins, x = 'bill_length_mm')
sns.histplot(data = penguins, x = 'flipper_length_mm')
corrs = penguins.corr()
mask = np.triu(np.ones_like(corrs, dtype=bool))
f, ax = plt.subplots(figsize=(11, 9))
cmap = sns.diverging_palette(230, 20, as_cmap=True)
sns.heatmap(corrs, mask=mask, cmap=cmap, vmax=.3, ce
nter=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5}) 